package com.emse.spring.faircorp.hello;


import java.util.Arrays;
import java.util.List;

import org.assertj.core.api.Assertions;
import org.assertj.core.groups.Tuple;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

//import com.devmind.testinaction.repository.FriendRepository;

@ExtendWith(MockitoExtension.class) // 1. We use MockitoExtension. This extension is able to manage annotations @Mock and @InjectMocks
class FriendServiceTest {

//    @Mock // 2. Property annotated with @Mock will be generated by Mockito. Mockito create a mock (each collaborators have to be defined as mocks). You can define a mock behavior on a test
//    private FriendRepository friendRepository;

//    @InjectMocks //3. The class to test is annotated @InjectMocks. Mockito create the implementation and inject automatically mocks inside
//    private FriendServiceImpl friendService;

    @Test
    public void computeFriendAgeAverage(){
        // Arrange
        List<Friend> myFriends = Arrays.asList(
                new Friend("Elodie", 1999),
                new Friend("Charles", 2001));

//        Mockito.when(friendRepository.findAll()).thenReturn(myFriends); // 4. You can define the mock object behavior in your test. Here, we want the mock will return a list of friends

        // Act
        double average = friendService.computeFriendAgeAverage(); // 5. You can call your SUT and check the result

        // Assert
        Assertions.assertThat(average).isEqualTo(21.0);
    }

    // Old code...

//    @Test
//    public void computeFriendAgeAverageWhenFriendListIsEmpty(){
//        // Arrange
//        List<Friend> myFriends = null;
//
//        Mockito.when(friendRepository.findAll()).thenReturn(myFriends);
//
//        // Act
//        // ...
//    Mockito.when(friendRepository.findAll()).thenThrow(new IllegalArgumentException("Error"));
//    }

    private FriendService friendService;

    @BeforeEach // 1. Method annotated with @BeforeEach is executed before each tests (a @AfterEach exists)
    public void init(){
        friendService = new FriendServiceImpl();
    }

    @Test // 2. Method annotated with @Test is a unit test.
    public void computeFriendAge() {
        // Arrange
        Friend friend = new Friend("Guillaume", 1977);

        // Act
        int age = friendService.computeFriendAge(friend);

        // Assert
        Assertions.assertThat(age).isEqualTo(42); // 3. We use assertJ to write assertions
        
        Assertions.assertThat(age).isEqualTo(41);
        Assertions.assertThat("totoName").isEqualTo("Dev-Mind");
        
        List<Friend> myFriends = Arrays.asList(
                new Friend("Elodie", 1999),
                new Friend("Charles", 2001));
        Assertions.assertThat(myFriends)
        .hasSize(2)
        .extracting(Friend::getName)
        .containsExactlyInAnyOrder("Elodie", "Charles");

		Assertions.assertThat(myFriends)
		.hasSize(2)
		.extracting(Friend::getName, Friend::getBirthYear)
		.containsExactlyInAnyOrder(
		        Tuple.tuple("Elodie", 1999),
		        Tuple.tuple("Charles", 2001));
    }

    @Test
    public void computeFriendAgeWithNullFriendShouldFail() { // 4. We expect an exception when friend is null. Itâ€™s important to use an explicit test method name
        Assertions.assertThatThrownBy(() -> friendService.computeFriendAge(null))
                .isExactlyInstanceOf(IllegalArgumentException.class)
                .hasMessage("Friend is required");
    }
}